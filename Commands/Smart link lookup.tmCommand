<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/usr/bin/env ruby -wKU
# http://brettterpstra.com/searchlink-automated-markdown-linking-improved/
# VERSION = 1.3
$: &lt;&lt; ENV['TM_BUNDLE_SUPPORT']
require 'net/https'
require 'rubygems'
require "#{ENV['TM_BUNDLE_SUPPORT']}/json"
require 'cgi'

# set to true to force inline links
inline = false
# append affiliate link info to iTunes urls, empty quotes for none
affiliate_string = "&amp;partnerId=30&amp;siteID=vRL5rYo4h5A"

input = STDIN.read

inline = true if input.scan(/\]\(!/).length == 1

def wiki(terms)
	uri = URI.parse("http://en.wikipedia.org/w/api.php?action=query&amp;format=json&amp;prop=info&amp;inprop=url&amp;titles=#{CGI.escape(terms)}")
	req = Net::HTTP::Get.new(uri.request_uri)
	req['Referer'] = "http://macromates.com"
	req['User-Agent'] = "SearchLink (http://macromates.com)"
	res = Net::HTTP.start(uri.host, uri.port) {|http|
	  http.request(req)
	}
	result = JSON.parse(res.body)

	if result
		result['query']['pages'].each do |page,info|
			return [info['fullurl'],info['title']]
		end
	end
end

def zero_click(terms)
	url = URI.parse("http://api.duckduckgo.com/?q=#{CGI.escape(terms)}&amp;format=json&amp;no_redirect=1&amp;no_html=1&amp;skip_disambig=1")
	res = Net::HTTP.get_response(url).body
	result = JSON.parse(res)
	if result
		definition      = result['Definition']    || false
		definition_link = result['DefinitionURL'] || false
		wiki_link       = result['AbstractURL']   || false
		title           = result['Heading']       || false
		return [title, definition, definition_link, wiki_link]
	else
		return false
	end
end

def itunes(entity, terms, dev, aff = '')
	url = URI.parse("http://itunes.apple.com/search?term=#{CGI.escape(terms)}&amp;entity=#{entity}")
	res = Net::HTTP.get_response(url).body
	json = JSON.parse(res)
	if json['resultCount']
		result = json['results'][0]
		case entity
		when /(mac|iPad)Software/
			output_url = dev &amp;&amp; result['sellerUrl'] ? result['sellerUrl'] : result['trackViewUrl'] + aff
			output_title = result['trackName']
		when /(musicArtist|song|album)/
			case result['wrapperType']
			when 'track'
				output_url = result['trackViewUrl']
				output_title = result['trackName'] + " by " + result['artistName']
			when 'collection'
				output_url = result['collectionViewUrl']
				output_title = result['collectionName'] + " by " + result['artistName']
			when 'artist'
				output_url = result['artistLinkUrl']
				output_title = result['artistName']
			end
		end
		return [output_url, output_title]
	else
		return false
	end
end

def lastfm(entity, terms)
	url = URI.parse("http://ws.audioscrobbler.com/2.0/?method=#{entity}.search&amp;#{entity}=#{CGI.escape(terms)}&amp;api_key=2f3407ec29601f97ca8a18ff580477de&amp;format=json")
	res = Net::HTTP.get_response(url).body
	json = JSON.parse(res)
	if json['results']
		case entity
		when 'track'
			result = json['results']['trackmatches']['track'][0]
			url = result['url']
			title = result['name'] + " by " + result['artist']
		when 'artist'
			result = json['results']['artistmatches']['artist'][0]
			url = result['url']
			title = result['name']
		end
		return [url, title]
	else
		return false
	end
end

def google(terms, define = false)
	uri = URI.parse("http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;filter=1&amp;rsz=small&amp;q=#{CGI.escape(terms)}")
	req = Net::HTTP::Get.new(uri.request_uri)
	req['Referer'] = "http://macromates.com"
	res = Net::HTTP.start(uri.host, uri.port) {|http|
	  http.request(req)
	}
	json = JSON.parse(res.body)
	if json['responseData']
		result = json['responseData']['results'][0]
		return false if result.nil?
		output_url = result['unescapedUrl']
		if define &amp;&amp; output_url =~ /dictionary/
			output_title = result['content'].gsub(/&lt;\/?.*?&gt;/,'')
		else
			output_title = result['titleNoFormatting']
		end
		return [output_url, output_title]
	else
		return false
	end
end

links = {}
footer = ''
highest_marker = 0

input.scan(/\[(\d+)\]: /).each do |match|
	highest_marker = $1.to_i if $1.to_i &gt; highest_marker
end

input.gsub!(/\[(.*?)\]\((\!.+?)\)/) do |match|
	link_text = $1
	link_info = $2
	search_type = ''
	search_terms = ''
	if link_info =~ /\!(.+) "(.*?)"$/
		search_type = $1
		search_terms = $2
	else
		search_word = link_info.match(/\!(.+)/)
		search_type = search_word[1] unless search_word.nil?
		search_terms = link_text
	end

	url   = false
	title = false

	case search_type
	when /^g$/ # google lucky search
		url, title = google(search_terms)

	when /^wiki$/
		url, title = wiki(search_terms)

	when /^def$/ # wikipedia/dictionary search
		# title, definition, definition_link, wiki_link = zero_click(search_terms)
		# if search_type == 'def' &amp;&amp; definition_link != ''
		# 	url = definition_link
		# 	title = definition.gsub(/'+/,"'")
		# elsif wiki_link != ''
		# 	url = wiki_link
		# 	title = "Wikipedia: #{title}"
		# end
		url, title = google("define " + search_terms, true)

	when /^masd?$/ # Mac App Store search (mas = itunes link, masd = developer link)
		dev = search_type =~ /d$/
		url, title = itunes('macSoftware',search_terms, dev, affiliate_string)

	when /^itud?$/ # iTunes app search
		dev = search_type =~ /d$/
		url, title = itunes('iPadSoftware',search_terms, dev, affiliate_string)

	when /^s$/ # software search (google)
		url, title = google("(software OR app) #{search_terms}")
		link_text = title if link_text == ''

	when /^isong$/ # iTunes Song Search
		url, title = itunes('song', search_terms, false)

	when /^iart$/ # iTunes Artist Search
		url, title = itunes('musicArtist', search_terms, false)

	when /^ialb$/ # iTunes Album Search
		url, title = itunes('album', search_terms, false)

	when /^lsong$/ # Last.fm Song Search
		url, title = lastfm('track', search_terms)

	when /^lart$/ # Last.fm Artist Search
		url, title = lastfm('artist', search_terms)
	else
		if search_type =~ /.+?\.\w{2,4}$/
			url, title = google("site:#{search_type} #{search_terms}")
		end
	end

	if url
		link_text = title if link_text == '' &amp;&amp; title
		if inline
			title ? %Q{[#{link_text}](#{url} "#{title}")} : %Q{[#{link_text}](#{url})}
		else
			if links.has_key? url
				marker = links[url].to_i + highest_marker
			else
				links[url] = links.length + 1 + highest_marker
				footer += %Q{\n[#{links[url]}]: #{url}}
				footer += %Q{ "#{title}"} if title
			end

			if title
				%Q{[#{link_text}][#{links[url]}]}
			else
				%Q{[#{link_text}](#{url})}
			end
		end
	else
		match
	end
end

if inline
	print input
else
	puts input
	puts footer
end
</string>
	<key>input</key>
	<string>selection</string>
	<key>inputFormat</key>
	<string>text</string>
	<key>name</key>
	<string>Replace smart-links</string>
	<key>outputCaret</key>
	<string>afterOutput</string>
	<key>outputFormat</key>
	<string>text</string>
	<key>outputLocation</key>
	<string>replaceInput</string>
	<key>uuid</key>
	<string>B2345092-190C-4658-98EB-68202BF38C64</string>
	<key>version</key>
	<integer>2</integer>
</dict>
</plist>
